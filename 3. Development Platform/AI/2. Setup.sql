/*
	*** Setup ***
*/

CREATE TABLE Movie (
	MovieId int IDENTITY,
	Title varchar(50)
)

-- Populate four movie titles
INSERT INTO Movie VALUES
	('Return of the Jedi'),
	('The Godfather'),
	('Animal House'),
	('The Two Towers')

-- Create a table to store the vector components for each movie, which will be obtained by calling Azure OpenAI
CREATE TABLE MovieVector (
	MovieId int,		-- Foreign key to the movie for this vector
	VectorValueId int,	-- Sequential ID (preserve ordering of each vector value)
	VectorValue float	-- Vector value
)
GO

-- Create a stored procedure that can call Azure OpenAI to vectorize any text
CREATE PROCEDURE VectorizeText
	@Text varchar(max)
AS
BEGIN

	DECLARE @OpenAIEndpoint varchar(max) = '[OPENAI-ENDPOINT]'		-- Your Azure OpenAI endpoint
	DECLARE @OpenAIApiKey varchar(max) = '[OPENAI-API-KEY]'				-- Your Azure OpenAI API key
	DECLARE @OpenAIDeploymentName varchar(max) = '[OPENAI-DEPLOYMENT-NAME]'			-- The 'Text Embedding 3 Large' model yields 3072 components (floating point values) per vector

	DECLARE @Url varchar(max) = CONCAT(@OpenAIEndpoint, 'openai/deployments/', @OpenAIDeploymentName, '/embeddings?api-version=2023-03-15-preview')
	DECLARE @Headers varchar(max) = JSON_OBJECT('api-key': @OpenAIApiKey)
	DECLARE @Payload varchar(max) = JSON_OBJECT('input': @Text)
	DECLARE @Response nvarchar(max)
	DECLARE @ReturnValue int

	-- Call Azure OpenAI via sp_invoke_external_rest_endpoint to vectorize the text
	-- Currently, sp_invoke_external_rest_endpoint is supported only by Azure SQL Database
	-- For SQL Server 2022, Azure OpenAI must be called via C# (either in the client app, or via SQL CLR)
	EXEC @ReturnValue = sp_invoke_external_rest_endpoint
		@url = @Url,
		@method = 'POST',
		@headers = @Headers,
		@payload = @Payload,
		@response = @Response OUTPUT

	IF @ReturnValue != 0
		THROW 50000, @Response, 1

	-- Parse the JSON response from Azure OpenAI to return the vector components
	SELECT
		VectorValueId = [key] + 1,	-- Produce sequential IDs 1 to 3072 from [key] values 0 to 3071 generated by OPENJSON
		VectorValue = value			-- Store the actual vector value from the JSON response
	FROM
		OPENJSON(@Response, '$.result.data[0].embedding')

END
GO

-- Create a stored procedure to run a vector search using the Cosine Distance metric
CREATE PROCEDURE VectorSearch
	@Question varchar(max)
AS
BEGIN

	-- Prepare a table variable to capture the question vector components returned from Azure OpenAI
	DECLARE @QuestionVector table (
		VectorValueId int,	-- Sequential ID (preserve ordering of each vector value)
		VectorValue float	-- Vector value
	)

	-- Vectorize the question, and store the question vector components in the table variable
	INSERT INTO @QuestionVector
		EXEC VectorizeText @Question

	SELECT TOP 1
		Question = @Question,
		Answer = m.Title,
		CosineDistance =										-- Calculate the cosine distance as:
			1 -														--	one minus
			(														--	(
				SUM(qv.VectorValue * mv.VectorValue) /				--		dot product (sum of the element-wise multiplication of corresponding vector values from the question and movie vectors) divided by
				(													--		(
					SQRT(SUM(qv.VectorValue * qv.VectorValue)) *	--			magnitude of the question vector (square root of the sum of squares of the question vector values) times
					SQRT(SUM(mv.VectorValue * mv.VectorValue))		--			magnitude of the movie vector (square root of the sum of squares of the movie vector values)
				)													--		)
			)														--	)
	FROM
		@QuestionVector AS qv													-- join the query vector components
		INNER JOIN MovieVector AS mv on qv.VectorValueId = mv.VectorValueId		-- to each movie's vector components, keeping both vector components in sequence based on the vector value ID
		INNER JOIN Movie AS m ON m.MovieId = mv.MovieId							-- also join on the Movie table to get the movie title
	GROUP BY
		mv.MovieId,		-- Treat each set of vector components as a single vector that can use SUM
		m.Title			-- Get the movie title of the most similar result 
	ORDER BY
		CosineDistance	-- Smaller distances (more similar) before larger distances (less similar), so TOP 1 gives the most similar match

END
GO

-- View the movie titles
SELECT * FROM Movie

-- View the empty vector table
SELECT * FROM MovieVector
